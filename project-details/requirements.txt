1. Login/Signup User 
	1. Admin
	2. Restaurant owner
	3. Customer
	4. JWT based Authentication + Authorization

2. Restaurant Owner
	1. Add branches
	2. Add tables at each branch( city level for simplicity)
	3. Add Dishes with price
	4. View booked tables by customer

3. Customer 
	1. Search by city
	2. Search by restaurant
	3. Search by food
	4. Book table at a restaurant date and start time
	
4. Admin
	1. View Restaurant tables and bookings
	2. View Restaurant foods
	3. View Customer bookings
	4. Add food categories
	5. Add Cities
	6. Add Dishes
	7. Add table

5. Assumptions
	1. Each slot is for 1 hour? No
	2. Can book for only T + 1 day
	3. One owner per restaurant? Yes
	4. Owner has multiple Restaurants? Yes
	5. User has Multiple roles? Yes
	6. Different Menu at each branch? No
	7. Availability at table level? No
	8. Removal supported? Yes
	9. Restaurant has multiple branches in a city? No
	10. An owner of an restaurant cannot update details of other restaurant? Obviously
	11. Image or Blob ? 

6. Practices to be followed
	1. REST
	2. Git commit
	3. SQL 
	4. Spring Data JPA
	5. Spring security
	6. Unit test cases
	7. Validation: An owner cannot update details of other restaurant
	8. Documentation

7. Future Enhancements
	1. Spring AOP
	2. Caching
	3. Data JPA Auditing

Learning:
	1. Normalization multiple branches for restaurant using xNF
	2. Normalization Menu to avoid multiple names
	3. Designing DB
	4. With Spring Security permit /error page to avoid 403 for every error
	5. ControllerAdvice handles exception after filter, errors before filter to be handled by 
		first filter and map to resolver, also handle RuntimeException
	6. JOIN FETCH to avoid N + 1
	7. Data JPA updates all fields by default fetch and update
	8. RBAC ABAC
	9. 
	
Concurrency:
	Locks:
		When some PORTION of the database is LOCKED, any other users wishing to
		modify (or read) that data must WAIT
		
		Two locking strategies:
		1. Write lock & read lock
		2. Write lock & read based on versioning(by DB to ensure 
		from start to end of query same data)
		
		
		Pros & cons:
		1. Long wait times if there are many concurrent read and write requests
		2. Problematic if there are long-running queries while data is being modified
		
		
		Granularities:
		1. Table lock
		2. Page lock (same segment of memory 2 - 16KB) of a table
		3. Row lock
		
		Pros & cons:
		1. +Little bookkeeping - More wait time
		2,3. -More bookkeeping + Less wait time (if modifying different rows)
		
	Transactions:
		Start Transaction
		good -> commit
		bad -> rollback
		
		If server shut down before commit/ rollback
		first thing after coming on online is rollback 
		If shut down after commit(is in memory) but before flush(move to permanent storage)
		first thing after coming on online is reapply
		
		
		Handling by DB 2 ways:
		1. Transaction is active always, if it ends automatically start new
		2. You start manually
		
		Either way used you have to explicity end the transaction
	
	
	Implementation:
		
		1. Versioning / Optimistic lock
			@Version, retrieve - process - update, before updating check version is same
			 as retrieve. Detecting changes on entities by checking their version attribute
			 
			 Pros & Cons:
			 1. + Easy to implement
			 2. + Less Overhead on application performance 
			 3. + No locks, so no waiting
			 4. + No silent lost/ over ride
			 5. + No dead locks
			 4. - Many rollbacks
			 
			 Suitable:
			 1. Where less updates/ deletes
			 2. Where less conflict of updating same resource 
			 3. Where lock cannot be held
			 4. Where transaction are short running
			 
			 Optimistic Lock is available by default to version-ed entities, but can request explicitly as well
			 
			 
		


		
		
		


	