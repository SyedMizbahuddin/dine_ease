1. Login/Signup User 
	1. Admin
	2. Restaurant owner
	3. Customer
	4. JWT based Authentication + Authorization

2. Restaurant Owner
	1. Add branches
	2. Add tables at each branch( city level for simplicity)
	3. Add Dishes with price
	4. View booked tables by customer

3. Customer 
	1. Search by city
	2. Search by restaurant
	3. Search by food
	4. Book table at a restaurant date and start time
	
4. Admin
	1. View Restaurant tables and bookings
	2. View Restaurant foods
	3. View Customer bookings
	4. Add food categories
	5. Add Cities
	6. Add Dishes
	7. Add table

5. Assumptions
	1. Each slot is for 1 hour? No
	2. Can book for only T + 1 day
	3. One owner per restaurant? Yes
	4. Owner has multiple Restaurants? Yes
	5. User has Multiple roles? Yes
	6. Different Menu at each branch? No
	7. Availability at table level? No
	8. Removal supported? Yes
	9. Restaurant has multiple branches in a city? No
	10. An owner of an restaurant cannot update details of other restaurant? Obviously
	11. Image or Blob ? 

6. Design changes
	1. Existing: branch tables - count, bookings - has Id
		To check available count - no. of bookings, concurrent bookings as booking is inserted, phantom read problem arises and cant be solved
		without Isolation.SERIALIZABLE which is in efficient


6. Practices to be followed
	1. REST
	2. Git commit
	3. SQL 
	4. Spring Data JPA
	5. Spring security
	6. Unit test cases
	7. Validation: An owner cannot update details of other restaurant
	8. Documentation

7. Future Enhancements
	1. Spring AOP
	2. Caching
	3. Data JPA Auditing

Learning:
	1. Normalization multiple branches for restaurant using xNF
	2. Normalization Menu to avoid multiple names
	3. Designing DB
	4. With Spring Security permit /error page to avoid 403 for every error
	5. ControllerAdvice handles exception after filter, errors before filter to be handled by 
		first filter and map to resolver, also handle RuntimeException
	6. JOIN FETCH to avoid N + 1
	7. Data JPA updates all fields by default fetch and update
	8. RBAC ABAC
	9. Adding @Transactional to update/delete methods only along with @Version
		for optimistic locking, as very less updates are expected. Not required for
		Create methods as DB handles duplicate creation based on unique constraints.
	10. 
	
Concurrency:
	https://medium.com/@bubu.tripathy/managing-concurrent-database-updates-eaf2fe161c48
	https://medium-parser-seven.vercel.app/?url=https://medium.com/@soyjuanmalopez/conquering-concurrency-in-spring-boot-strategies-and-solutions-152f41dd9005
	Locks:
		When some PORTION of the database is LOCKED, any other users wishing to
		modify (or read) that data must WAIT
		
		Two locking strategies:
		1. Write lock & read lock
		2. Write lock & read based on versioning(by DB to ensure 
		from start to end of query same data)
		
		
		Pros & cons:
		1. Long wait times if there are many concurrent read and write requests
		2. Problematic if there are long-running queries while data is being modified
		
		
		Granularities:
		1. Table lock
		2. Page lock (same segment of memory 2 - 16KB) of a table
		3. Row lock
		
		Pros & cons:
		1. +Little bookkeeping - More wait time
		2,3. -More bookkeeping + Less wait time (if modifying different rows)
		
	Transactions:
		Start Transaction
		good -> commit
		bad -> rollback
		
		If server shut down before commit/ rollback
		first thing after coming on online is rollback 
		If shut down after commit(is in memory) but before flush(move to permanent storage)
		first thing after coming on online is reapply
		
		
		Handling by DB 2 ways:
		1. Transaction is active always, if it ends automatically start new
		2. You start manually
		
		Either way used you have to explicity end the transaction

	
	
	Implementation:
		
		1. Versioning / Optimistic lock
			@Version, retrieve - process - update, before updating check version is same
			 as retrieve. Detecting changes on entities by checking their version attribute
			 
			 Pros & Cons:
			 1. + Easy to implement
			 2. + Less Overhead on application performance 
			 3. + No locks, so no waiting
			 4. + No silent lost/ over ride
			 5. + No dead locks
			 4. - Many rollbacks
			 
			 Suitable:
			 1. Where less updates/ deletes
			 2. Where less conflict of updating same resource 
			 3. Where lock cannot be held
			 4. Where transaction are short running
			 
			 Optimistic Lock is available by default to version-ed entities, but can request explicitly as well
			 ObjectOptimisticLockingFailureException
			 
			 
			
		2. Transactional 
			It has Propagation, Isolation, readOnly, Timeout, rollBack
			imp: Propagation, isolation
			logging.level.org.springframework=trace to see the transactions/orm

			What I understood so far is, it maintains atomicity. But concurrency is not his business
			It will roll back if any error, so can use with optimistic Locking

			Roll back does not happen on checked Excep
			Only on unchecked

			Propagation:
				How transactions are created for methods called under a transaction
				How existing transactions are getting used


			Concurrency Problems + Concurrency solution - Isolation:
			https://jennyttt.medium.com/dirty-read-non-repeatable-read-and-phantom-read-bd75dd69d03a

			read uncommited:
				No locks

			read commited:


			Repeatable_read:
				The queried rows are locked, so other cannot update

			Serializable:
				Table is locked


		3. Pessimistc Locking
			SELECT * FROM product WHERE id = ? FOR UPDATE
			Once an entity is locked, other transactions trying to access or update the same entity will have to wait until the lock is released. This ensures that only one transaction can access the entity at a time, preventing concurrency issues.
			
			@Lock(LockModeType.PESSIMISTIC_WRITE)
    		MyEntity findById(Long id);

    		Pros & Cons:
    		1. + Strong way to prevent con issue
    		2. - Locks, Waiting so Performance, Deadlocks

		4. Application level locking
			1. synchronised(lock){
				...
				...
			}
			2. java.util.concurrent.atomic
			3. java.util.concurrent.locks.Lock

			
		


		
		
		


	